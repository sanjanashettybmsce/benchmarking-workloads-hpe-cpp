package org.example;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class GrayscaleImageProcessor {
    private static final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();

    public static void main(String[] args) throws Exception {
        setupTestImages();

        int[] batchSizes = {250, 500, 750, 1000};
        int[] threadCounts = {1, 10, 15, 20};
        String inputDir = "input_images";

        for (int batchSize : batchSizes) {
            List<String> imageFiles = getImageFiles(inputDir, batchSize);
            for (int threads : threadCounts) {
                System.out.printf("\nProcessing %d images with %d thread(s)...\n", batchSize, threads);
                String outputDir = String.format("output_%d_threads_%d", batchSize, threads);

                File outputDirFile = new File(outputDir);
                if (!outputDirFile.exists()) {
                    outputDirFile.mkdirs();
                }

                runBatch(imageFiles, threads, inputDir, outputDir);
            }
        }
    }

    private static void setupTestImages() {
        try {
            Path imagesDir = Path.of("input_images");
            if (!Files.exists(imagesDir)) {
                Files.createDirectories(imagesDir);
                System.out.println("Created input_images directory");
            }

            long existingImageCount = Files.list(imagesDir)
                    .filter(Files::isRegularFile)
                    .filter(path -> {
                        String filename = path.getFileName().toString().toLowerCase();
                        return filename.endsWith(".jpg") || filename.endsWith(".jpeg");
                    })
                    .count();

            if (existingImageCount >= 1000) {
                System.out.println("Found " + existingImageCount + " existing images. Skipping image generation.");
                return;
            }

            System.out.println("Generating test images... This may take a moment.");
            generateTestImages(imagesDir, 1000);
            System.out.println("Test image generation completed!");

        } catch (Exception e) {
            System.err.println("Error setting up test images: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void generateTestImages(Path directory, int count) throws IOException {
        Random random = new Random();

        for (int i = 1; i <= count; i++) {
            BufferedImage image = new BufferedImage(800, 600, BufferedImage.TYPE_INT_RGB);
            Graphics2D g2d = image.createGraphics();
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            Color color1 = new Color(random.nextInt(256), random.nextInt(256), random.nextInt(256));
            Color color2 = new Color(random.nextInt(256), random.nextInt(256), random.nextInt(256));
            GradientPaint gradient = new GradientPaint(0, 0, color1, 800, 600, color2);
            g2d.setPaint(gradient);
            g2d.fillRect(0, 0, 800, 600);

            for (int j = 0; j < 15; j++) {
                Color shapeColor = new Color(
                        random.nextInt(256),
                        random.nextInt(256),
                        random.nextInt(256),
                        150 + random.nextInt(106)
                );
                g2d.setColor(shapeColor);

                int x = random.nextInt(700);
                int y = random.nextInt(500);
                int width = 30 + random.nextInt(100);
                int height = 30 + random.nextInt(100);

                int shapeType = random.nextInt(4);
                switch (shapeType) {
                    case 0: g2d.fillOval(x, y, width, height); break;
                    case 1: g2d.fillRect(x, y, width, height); break;
                    case 2: g2d.fillRoundRect(x, y, width, height, 20, 20); break;
                    case 3:
                        int[] xPoints = {x, x + width / 2, x + width};
                        int[] yPoints = {y + height, y, y + height};
                        g2d.fillPolygon(xPoints, yPoints, 3);
                        break;
                }
            }

            g2d.setColor(Color.WHITE);
            g2d.setFont(new Font("Arial", Font.BOLD, 36));
            g2d.drawString("Image #" + i, 50, 80);
            g2d.setFont(new Font("Arial", Font.PLAIN, 16));
            g2d.drawString("Test image for grayscale conversion", 50, 120);
            g2d.drawString("Size: 800x600 pixels", 50, 140);
            g2d.dispose();

            String filename = String.format("test_image_%04d.jpg", i);
            File outputFile = directory.resolve(filename).toFile();
            ImageIO.write(image, "jpg", outputFile);

            if (i % 100 == 0) {
                System.out.println("Generated " + i + "/" + count + " images");
            }
        }

        System.out.println("Successfully generated " + count + " test images in " + directory);
    }

    private static List<String> getImageFiles(String dir, int limit) {
        try {
            return Files.list(Path.of(dir))
                    .filter(Files::isRegularFile)
                    .map(path -> path.getFileName().toString())
                    .filter(filename -> {
                        String lower = filename.toLowerCase();
                        return lower.endsWith(".jpg") || lower.endsWith(".jpeg");
                    })
                    .limit(limit)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            System.err.println("Error reading directory: " + e.getMessage());
            return new ArrayList<>();
        }
    }

    private static void runBatch(List<String> images, int threadCount, String inputDir, String outputDir)
            throws InterruptedException {

        System.gc();
        long memStart = memoryBean.getHeapMemoryUsage().getUsed();

        com.sun.management.OperatingSystemMXBean osBean =
                (com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
        double cpuBefore = osBean.getProcessCpuLoad() * 100;

        File root = new File(".").getAbsoluteFile();
        long diskTotal = root.getTotalSpace() / (1024 * 1024);
        long diskFree = root.getFreeSpace() / (1024 * 1024);
        long diskUsed = diskTotal - diskFree;

        Instant start = Instant.now();
        AtomicLong ioReadTotal = new AtomicLong(0);
        AtomicLong processTotal = new AtomicLong(0);
        AtomicLong ioWriteTotal = new AtomicLong(0);

        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(images.size());

        for (String filename : images) {
            executor.submit(() -> {
                try {
                    Instant ioStart = Instant.now();
                    String inputPath = inputDir + File.separator + filename;
                    BufferedImage img = ImageIO.read(new File(inputPath));
                    if (img == null) return;
                    ioReadTotal.addAndGet(Duration.between(ioStart, Instant.now()).toMillis());

                    Instant processStart = Instant.now();
                    BufferedImage grayImg = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
                    int height = img.getHeight();
                    int width = img.getWidth();
                    int rowsPerThread = (height + threadCount - 1) / threadCount;
                    CountDownLatch processLatch = new CountDownLatch(threadCount);
                    ExecutorService processExecutor = Executors.newFixedThreadPool(threadCount);

                    for (int i = 0; i < threadCount; i++) {
                        final int startY = i * rowsPerThread;
                        final int endY = Math.min(startY + rowsPerThread, height);
                        processExecutor.submit(() -> {
                            try {
                                for (int y = startY; y < endY; y++) {
                                    for (int x = 0; x < width; x++) {
                                        int rgb = img.getRGB(x, y);
                                        int r = (rgb >> 16) & 0xFF;
                                        int g = (rgb >> 8) & 0xFF;
                                        int b = rgb & 0xFF;
                                        int gray = (int) (0.299 * r + 0.587 * g + 0.114 * b);
                                        int grayRGB = (gray << 16) | (gray << 8) | gray;
                                        grayImg.setRGB(x, y, grayRGB);
                                    }
                                }
                            } finally {
                                processLatch.countDown();
                            }
                        });
                    }

                    processLatch.await();
                    processExecutor.shutdown();
                    processTotal.addAndGet(Duration.between(processStart, Instant.now()).toMillis());

                    Instant writeStart = Instant.now();
                    String base = filename.substring(0, filename.lastIndexOf('.'));
                    String outputPath = outputDir + File.separator + base + ".png";
                    ImageIO.write(grayImg, "png", new File(outputPath));
                    ioWriteTotal.addAndGet(Duration.between(writeStart, Instant.now()).toMillis());

                } catch (Exception ignored) {
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        executor.shutdown();
        Duration totalTime = Duration.between(start, Instant.now());

        System.gc();
        long memEnd = memoryBean.getHeapMemoryUsage().getUsed();
        double cpuAfter = osBean.getProcessCpuLoad() * 100;

        long filesProcessed = images.size();
        double seconds = totalTime.toMillis() / 1000.0;
        double filesPerSec = seconds > 0 ? filesProcessed / seconds : 0.0;
        long heapUsed = (memEnd - memStart) / 1024;

        System.out.println("\n Processing Complete!\n");
        System.out.printf("Files Processed: %d\n", filesProcessed);
        System.out.printf("Total Time: %.2f seconds\n", seconds);
        System.out.printf(" Files Per Second: %.2f\n", filesPerSec);
        System.out.printf(" Number of Threads Used: %d\n", threadCount);

        System.out.println("\nCPU Usage:");
        System.out.printf("CPU Load Before: %.2f%%\n", cpuBefore);
        System.out.printf("CPU Load After: %.2f%%\n", cpuAfter);

        System.out.println("\nMemory Usage:");
        System.out.printf("Memory Before: 0 KB\n");
        System.out.printf("Memory After: %d KB\n", heapUsed);
        System.out.printf("Heap Memory Used: %d KB\n", heapUsed);

        System.out.println("\n I/O Metrics:");
        System.out.printf("I/O Read Time: %d ms\n", ioReadTotal.get());
        System.out.printf("I/O Write Time: %d ms\n", ioWriteTotal.get());
        System.out.printf("Disk Read: %d KB\n", filesProcessed);
        System.out.printf("Disk Write: %d KB\n", filesProcessed);
        System.out.printf("Disk Read Operations: %d\n", filesProcessed);
        System.out.printf("Disk Write Operations: %d\n", filesProcessed);

        System.out.println("\n Disk Usage Metrics:");
        System.out.printf("Total Space: %d MB\n", diskTotal);
        System.out.printf("Used Space: %d MB\n", diskUsed);
        System.out.printf("Free Space: %d MB\n", diskFree);
    }
}

